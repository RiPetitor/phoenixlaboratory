---
sidebar_position: 6
---

# Внешние и статические объекты

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Что такое внешние и статические объекты

**Внешние объекты** (`extern`) — переменные и функции, объявленные в одном файле, но доступные в других файлах программы.

**Статические объекты** (`static`) — переменные и функции с ограниченной областью видимости и особым временем жизни.

## Статические переменные

### Статические локальные переменные

<Tabs>
<TabItem value="static-local" label="Сохранение значения между вызовами" default>

```c
#include <stdio.h>

int getNextNumber() {
    static int counter = 0;  // Инициализируется только один раз
    counter++;
    return counter;
}

void resetCounter() {
    static int resetCount = 0;
    resetCount++;
    printf("Функция сброса вызвана %d раз\n", resetCount);
}

int main() {
    printf("Генерация последовательных номеров:\n");

    for (int i = 0; i < 5; i++) {
        int num = getNextNumber();
        printf("Номер %d: %d\n", i + 1, num);
    }

    resetCounter();
    resetCounter();

    printf("\nПродолжаем генерацию:\n");
    for (int i = 0; i < 3; i++) {
        int num = getNextNumber();
        printf("Номер %d: %d\n", i + 6, num);
    }

    return 0;
}
```

</TabItem>
<TabItem value="comparison" label="Сравнение с обычными переменными">

```c
#include <stdio.h>

void normalFunction() {
    int normalVar = 0;  // Обычная переменная
    normalVar++;
    printf("Обычная переменная: %d\n", normalVar);
}

void staticFunction() {
    static int staticVar = 0;  // Статическая переменная
    staticVar++;
    printf("Статическая переменная: %d\n", staticVar);
}

int main() {
    printf("Сравнение поведения переменных:\n");

    for (int i = 0; i < 4; i++) {
        printf("Вызов %d:\n", i + 1);
        normalFunction();  // Всегда выводит 1
        staticFunction();  // Выводит 1, 2, 3, 4
        printf("\n");
    }

    return 0;
}
```

</TabItem>
</Tabs>

### Статические глобальные переменные

```c
#include <stdio.h>

static int moduleCounter = 0;  // Видна только в этом файле
int globalCounter = 0;         // Видна во всех файлах программы

static void internalFunction() {  // Функция только для этого файла
    moduleCounter++;
    printf("Внутренний счетчик: %d\n", moduleCounter);
}

void publicFunction() {  // Функция доступна другим файлам
    globalCounter++;
    internalFunction();
    printf("Глобальный счетчик: %d\n", globalCounter);
}

int main() {
    printf("Работа со статическими объектами:\n");

    for (int i = 0; i < 3; i++) {
        publicFunction();
        printf("---\n");
    }

    return 0;
}
```

## Внешние объекты (extern)

### Объявление внешних переменных

```c
#include <stdio.h>

// Имитируем переменные из другого файла
int sharedData = 1000;     // Определение переменной
float sharedPrice = 99.99; // Определение переменной

// В реальной программе эти extern объявления были бы в другом файле:
extern int sharedData;     // Объявление внешней переменной
extern float sharedPrice;  // Объявление внешней переменной

void modifySharedData() {
    sharedData += 100;
    sharedPrice *= 1.1;
    printf("Данные изменены в другом модуле\n");
}

int main() {
    printf("Исходные значения:\n");
    printf("sharedData: %d\n", sharedData);
    printf("sharedPrice: %.2f\n", sharedPrice);

    modifySharedData();

    printf("После изменения:\n");
    printf("sharedData: %d\n", sharedData);
    printf("sharedPrice: %.2f\n", sharedPrice);

    return 0;
}
```

### Внешние функции

<Tabs>
<TabItem value="extern-functions" label="Объявление внешних функций" default>

```c
#include <stdio.h>

// Объявления функций (обычно в заголовочных файлах)
extern int calculateSum(int a, int b);
extern void printReport(char *title);

// Определения функций (обычно в других .c файлах)
int calculateSum(int a, int b) {
    return a + b;
}

void printReport(char *title) {
    printf("=== %s ===\n", title);
    printf("Отчет сгенерирован успешно\n");
}

int main() {
    int result = calculateSum(10, 20);
    printf("Результат внешней функции: %d\n", result);

    printReport("ФИНАНСОВЫЙ ОТЧЕТ");

    return 0;
}
```

</TabItem>
<TabItem value="function-visibility" label="Видимость функций">

```c
#include <stdio.h>

// Статическая функция (только для этого файла)
static void privateHelper() {
    printf("Это приватная функция модуля\n");
}

// Обычная функция (доступна другим файлам)
void publicInterface() {
    printf("Это публичная функция\n");
    privateHelper();  // Можем вызывать приватные функции внутри модуля
}

int main() {
    publicInterface();

    // В других файлах privateHelper() будет недоступна

    return 0;
}
```

</TabItem>
</Tabs>

## Практические применения

### Система счетчиков

```c
#include <stdio.h>

// Модуль счетчиков
static int userLoginCount = 0;
static int errorCount = 0;
static int successCount = 0;

void recordLogin(int success) {
    userLoginCount++;

    if (success) {
        successCount++;
        printf("✅ Успешный вход #%d\n", successCount);
    } else {
        errorCount++;
        printf("❌ Ошибка входа #%d\n", errorCount);
    }
}

void getStatistics(int *total, int *errors, int *successes) {
    *total = userLoginCount;
    *errors = errorCount;
    *successes = successCount;
}

void resetStatistics() {
    userLoginCount = 0;
    errorCount = 0;
    successCount = 0;
    printf("Статистика сброшена\n");
}

int main() {
    printf("Система входа в систему:\n");

    // Имитируем попытки входа
    recordLogin(1);  // Успех
    recordLogin(0);  // Ошибка
    recordLogin(1);  // Успех
    recordLogin(0);  // Ошибка
    recordLogin(1);  // Успех

    int total, errors, successes;
    getStatistics(&total, &errors, &successes);

    printf("\n=== ИТОГОВАЯ СТАТИСТИКА ===\n");
    printf("Всего попыток: %d\n", total);
    printf("Успешных: %d\n", successes);
    printf("Ошибок: %d\n", errors);
    printf("Процент успеха: %.1f%%\n", (float)successes / total * 100);

    return 0;
}
```

### Конфигурация модуля

<Tabs>
<TabItem value="module-config" label="Настройки модуля" default>

```c
#include <stdio.h>

// Приватные настройки модуля
static int maxConnections = 10;
static float timeout = 30.0;
static char serverName[50] = "localhost";

// Приватные функции
static void logMessage(char *message) {
    printf("[LOG] %s\n", message);
}

static int validateConnection() {
    static int currentConnections = 0;

    if (currentConnections >= maxConnections) {
        return 0;  // Превышен лимит
    }

    currentConnections++;
    return 1;  // Соединение разрешено
}

// Публичные функции
void connectToServer() {
    if (validateConnection()) {
        logMessage("Подключение к серверу установлено");
        printf("Сервер: %s, таймаут: %.0f сек\n", serverName, timeout);
    } else {
        logMessage("Превышен лимит подключений");
    }
}

void getServerInfo() {
    printf("Информация о сервере:\n");
    printf("Имя: %s\n", serverName);
    printf("Макс. подключений: %d\n", maxConnections);
    printf("Таймаут: %.0f сек\n", timeout);
}

int main() {
    getServerInfo();

    printf("\nПопытки подключения:\n");
    for (int i = 0; i < 12; i++) {
        printf("Попытка %d: ", i + 1);
        connectToServer();
    }

    return 0;
}
```

</TabItem>
<TabItem value="state-machine" label="Машина состояний">

```c
#include <stdio.h>

// Состояния системы
typedef enum {
    STATE_IDLE,
    STATE_PROCESSING,
    STATE_WAITING,
    STATE_ERROR
} SystemState;

static SystemState currentState = STATE_IDLE;
static int operationCount = 0;

static void changeState(SystemState newState) {
    printf("Состояние: ");
    switch (currentState) {
        case STATE_IDLE: printf("ПРОСТОЙ"); break;
        case STATE_PROCESSING: printf("ОБРАБОТКА"); break;
        case STATE_WAITING: printf("ОЖИДАНИЕ"); break;
        case STATE_ERROR: printf("ОШИБКА"); break;
    }
    printf(" → ");

    currentState = newState;

    switch (currentState) {
        case STATE_IDLE: printf("ПРОСТОЙ\n"); break;
        case STATE_PROCESSING: printf("ОБРАБОТКА\n"); break;
        case STATE_WAITING: printf("ОЖИДАНИЕ\n"); break;
        case STATE_ERROR: printf("ОШИБКА\n"); break;
    }
}

void startOperation() {
    if (currentState == STATE_IDLE) {
        changeState(STATE_PROCESSING);
        operationCount++;
    } else {
        printf("Система занята\n");
    }
}

void finishOperation() {
    if (currentState == STATE_PROCESSING) {
        changeState(STATE_IDLE);
        printf("Операция #%d завершена\n", operationCount);
    }
}

int main() {
    printf("Демонстрация машины состояний:\n");

    startOperation();   // ПРОСТОЙ → ОБРАБОТКА
    finishOperation();  // ОБРАБОТКА → ПРОСТОЙ
    startOperation();   // ПРОСТОЙ → ОБРАБОТКА
    startOperation();   // Система занята
    finishOperation();  // ОБРАБОТКА → ПРОСТОЙ

    return 0;
}
```

</TabItem>
</Tabs>

## Различия между static и extern

### Сравнительная таблица

| Аспект | `static` | `extern` |
|--------|----------|----------|
| **Область видимости** | Ограничена файлом | Доступна во всех файлах |
| **Время жизни** | Весь период выполнения | Весь период выполнения |
| **Инициализация** | Один раз при первом вызове | При старте программы |
| **Назначение** | Скрытие от других модулей | Совместное использование |

### Практическое сравнение

```c
#include <stdio.h>

// Статические объекты (приватные для этого файла)
static int privateCounter = 0;
static void privateFunction() {
    privateCounter++;
    printf("Приватный счетчик: %d\n", privateCounter);
}

// Глобальные объекты (доступные другим файлам)
int publicCounter = 0;
void publicFunction() {
    publicCounter++;
    printf("Публичный счетчик: %d\n", publicCounter);
}

// Использование внешних объектов (из других файлов)
extern int externalData;  // Объявляем, что переменная определена в другом файле

int main() {
    printf("Демонстрация видимости:\n");

    // Используем приватные объекты
    privateFunction();
    privateFunction();

    // Используем публичные объекты
    publicFunction();
    publicFunction();

    // externalData = 100;  // Если бы была определена в другом файле

    return 0;
}
```

## Практические применения статических объектов

### Система уникальных идентификаторов

```c
#include <stdio.h>

static int nextUserId = 1000;
static int nextOrderId = 5000;

int generateUserId() {
    return nextUserId++;
}

int generateOrderId() {
    return nextOrderId++;
}

void createUser(char *name) {
    int userId = generateUserId();
    printf("👤 Создан пользователь: %s (ID: %d)\n", name, userId);
}

void createOrder(int userId, float amount) {
    int orderId = generateOrderId();
    printf("🛒 Создан заказ #%d для пользователя %d на сумму %.2f\n",
           orderId, userId, amount);
}

int main() {
    printf("Система управления:\n");

    createUser("Анна Петрова");
    createUser("Иван Сидоров");

    createOrder(1000, 1250.50);
    createOrder(1001, 890.75);
    createOrder(1000, 450.00);

    return 0;
}
```

### Кэширование результатов

<Tabs>
<TabItem value="cache" label="Кэш вычислений" default>

```c
#include <stdio.h>

int expensiveCalculation(int n) {
    static int cache[10] = {0};  // Кэш для результатов
    static int cacheSize = 0;

    // Проверяем кэш
    for (int i = 0; i < cacheSize; i++) {
        if (cache[i] == n) {
            printf("Результат взят из кэша\n");
            return n * n * n;  // Возвращаем из кэша
        }
    }

    // Вычисляем и сохраняем в кэш
    printf("Выполняем сложное вычисление для %d\n", n);

    if (cacheSize < 10) {
        cache[cacheSize] = n;
        cacheSize++;
    }

    return n * n * n;  // Куб числа
}

int main() {
    printf("Тестирование кэширования:\n");

    printf("Результат для 3: %d\n", expensiveCalculation(3));
    printf("Результат для 5: %d\n", expensiveCalculation(5));
    printf("Результат для 3: %d\n", expensiveCalculation(3));  // Из кэша
    printf("Результат для 7: %d\n", expensiveCalculation(7));
    printf("Результат для 5: %d\n", expensiveCalculation(5));  // Из кэша

    return 0;
}
```

</TabItem>
<TabItem value="session" label="Управление сессией">

```c
#include <stdio.h>

static char currentUser[50] = "";
static int isLoggedIn = 0;
static int sessionTime = 0;

void login(char *username) {
    if (!isLoggedIn) {
        // Простое копирование имени (в реальности используйте strcpy)
        int i = 0;
        while (username[i] != '\0' && i < 49) {
            currentUser[i] = username[i];
            i++;
        }
        currentUser[i] = '\0';

        isLoggedIn = 1;
        sessionTime = 0;
        printf("✅ Пользователь %s вошел в систему\n", currentUser);
    } else {
        printf("❌ Пользователь уже авторизован\n");
    }
}

void logout() {
    if (isLoggedIn) {
        printf("👋 Пользователь %s вышел из системы\n", currentUser);
        printf("Время сессии: %d минут\n", sessionTime);
        isLoggedIn = 0;
        currentUser[0] = '\0';
        sessionTime = 0;
    } else {
        printf("❌ Никто не авторизован\n");
    }
}

void updateSession() {
    if (isLoggedIn) {
        sessionTime += 5;  // Добавляем 5 минут
        printf("⏱️ Активность: %s онлайн %d мин\n", currentUser, sessionTime);
    }
}

int main() {
    printf("Система авторизации:\n");

    login("Анна");
    updateSession();
    updateSession();
    logout();

    printf("\nПопытка повторного входа:\n");
    login("Петр");
    updateSession();
    logout();

    return 0;
}
```

</TabItem>
</Tabs>

## Инициализация статических переменных

### Правила инициализации

```c
#include <stdio.h>

void demonstrateInitialization() {
    static int initialized = 100;    // Инициализируется один раз
    static int notInitialized;       // Автоматически инициализируется нулем
    int automatic = 50;              // Инициализируется каждый вызов

    printf("initialized: %d\n", initialized);
    printf("notInitialized: %d\n", notInitialized);
    printf("automatic: %d\n", automatic);

    initialized += 10;
    notInitialized += 5;
    automatic += 20;

    printf("После изменения:\n");
    printf("initialized: %d\n", initialized);
    printf("notInitialized: %d\n", notInitialized);
    printf("automatic: %d\n", automatic);
    printf("---\n");
}

int main() {
    printf("Тест инициализации:\n");

    for (int i = 0; i < 3; i++) {
        printf("Вызов %d:\n", i + 1);
        demonstrateInitialization();
    }

    return 0;
}
```

:::info Ключевые особенности
- **Статические переменные** инициализируются только один раз
- **Статические объекты** существуют в течение всего времени выполнения программы
- **static** ограничивает видимость файлом
- **extern** расширяет видимость на всю программу
- **Неинициализированные статические переменные** автоматически обнуляются
:::

:::tip Когда использовать
**static:**
- Для сохранения состояния между вызовами функций
- Для скрытия внутренних данных модуля
- Для создания уникальных идентификаторов

**extern:**
- Для разделения данных между файлами
- Для создания глобальных конфигураций
- Для доступа к функциям из других модулей
:::

:::warning Осторожность
- **Избегайте избыточных глобальных переменных** — они усложняют отладку
- **Статические переменные** могут затруднить тестирование
- **Всегда инициализируйте** статические переменные явно
:::

Внешние и статические объекты позволяют контролировать видимость и время жизни данных в сложных программах.
